package org.programmers.level3;

public class Solution2ByLv3 {

    /**
     * 이 문제는 카테고리부터 DP라고 나와있어 DP가 무엇인지 개념부터 학습한 후 진행하였다.
     * DP는 동적계획법으로 큰 문제를 작은 문제로 분할하여 해결하는 기법으로
     * 현재 문제에서는 꼭대기에서 아래로 내려가며 모든 경우의 수를 계산하면
     * 경우의 수 자체가 천문학적으로 증가하므로 푸는 것이 사실상 불가능하다.
     * 그래서 문제를 작은 문제로 분할하는 것이 무엇인지부터 정의하였다.
     *
     * 큰 문제는 위로부터 뻗어나가는 모든 루트일 것이다.
     * 그렇다면 문제를 작은 문제로 분할해보자.
     * 요구는 가장 큰 합으로 이어지는 경로를 찾는 것이다.
     * 그렇다면 위로부터가 아닌 아래로부터 합을 진행한다면 작은 문제로 분할했다고 할 수 있을 것이다.
     * 현재 위치에서 아래(삼각형 구조 기준)행에 배열이 존재한다면 행 + 1에서 현재 인덱스와
     * 현재 인덱스 +1까지가 합의 범위이므로 현재의 값과 다음 행의 두 값의 합 중 큰 값으로
     * 현재 배열에 저장해 나간다면 최종적으로 맨 꼭대기의 값은 경로중 가장 큰 값으로 저장될 것이다.
     * 반복문마다 아래 행 존재 여부 체크는 불필요한 작업이므로 행 개수가 1일때는 바로 값을 리턴하고
     * 아니라면 마지막 요소 바로 위의 행부터 반복문을 순회하여 최종적으로 꼭대기의 값을 반환하면 될 것이다.
     */

    public int solution(int[][] triangle) {
        int height = triangle.length;
        if(height == 1) return triangle[0][0];

        for(int i = height - 2; i >= 0; i--) {
            for(int j = 0; j < triangle[i].length; j++) {
                int now = triangle[i][j];
                for(int k = j; k <= j + 1; k++) {
                    triangle[i][j] = Math.max(
                            now + triangle[i + 1][k], triangle[i][j]
                    );
                }
            }
        }

        return triangle[0][0];
    }

}