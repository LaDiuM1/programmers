package org.programmers.level3;

public class Solution4ByLv3 {

    /**
     *  DP 알고리즘을 이전에 학습하여 DP를 이용해 진행하였다.
     *  이 문제는 결국 특정 방향으로만 진행하는 경로에서 각 경로마다 분기점을 확인하는 게 곧
     *  골인 지점에서의 최종 경로의 수가 될 것이라고 생각할 수 있었다.
     *  그렇다면 우측과 아래로만 진행하는 방향에서 분기점은 당연히 우측과 아래를 동시에
     *  갈 수 있는지 확인하는 것이며, 이를 일반적인 알고리즘으로 푼다면 갈림길에 도달할 때마다
     *  새로운 루트로 탐색을 진행하는 엄청난 경우의 수를 맞닥뜨릴 것이 뻔하기 때문에
     *  DP를 이용해 구상을 진행하였다. DP적으로 이 문제를 작은 문제로 분할한다면
     *  현재 위치 기준 현재 위치로 올 수 있었던 위치가 1개인지 두 개인지 확인하며 분기점 수를
     *  현재 위치에 더해 나간다면 최종적으로 도달점에서는 모든 루트의 합이 남을 것이다.
     *  구상을 완료하였으니 실제 구현을 진행하였다.
     *
     *  - 구현에서 처음에는 대각선으로 이동하며 순회하는 방법을 생각하여 구현을 진행하였으나
     *  구현 진행 도중 단순 배열 순회로도 같은 결과를 알 수 있음을 직관하였다. 1차적으로
     *  오른쪽 위, 왼쪽 아래로 순회하는 메서드를 생성 후 반복하여 최종 목적지까지 도달하는 방법으로
     *  문제를 해결하였으나, 이 문제에서는 단순 배열 순회만으로 간단하게 풀 수 있으므로 코드를 다시 작성하였다.
     *  가끔은 단순하게 생각하는 것이 정답인 경우가 있음을 확인하는 문제였으며, 1차 도전의 흔적은 아래에 주석 처리하였다.
     *
     *  여담이지만 이번에 알 수 있었던 놀라운 점은 1차 해결 방식은 여러 메서드를 호출하며 메서드 안에서도 각종 조건을 확인하는 방식이라
     *  시간적인 측면에서 아주 큰 차이를 보일 것으로 생각되었으나 실제 정확성과 효율성 테스트에서 생각보다 큰 차이가 나지
     *  않았다는 것이다. JAVA가 각 코드를 호출하고 처리하는 게 얼마나 효율적인지 알 수 있는 신기한 경험이었다.
     *
     * 1차 시도
     * 정확성  테스트
     * 테스트 1 〉	통과 (0.03ms, 81.4MB)
     * 테스트 2 〉	통과 (0.04ms, 71.6MB)
     * 테스트 3 〉	통과 (0.06ms, 79.1MB)
     * 테스트 4 〉	통과 (0.07ms, 70.3MB)
     * 테스트 5 〉	통과 (0.08ms, 64.8MB)
     * 테스트 6 〉	통과 (0.05ms, 79.3MB)
     * 테스트 7 〉	통과 (0.05ms, 77.4MB)
     * 테스트 8 〉	통과 (0.06ms, 68.4MB)
     * 테스트 9 〉	통과 (0.05ms, 74MB)
     * 테스트 10 〉	통과 (0.05ms, 80.3MB)
     * 효율성  테스트
     * 테스트 1 〉	통과 (1.07ms, 70.1MB)
     * 테스트 2 〉	통과 (0.66ms, 51.9MB)
     * 테스트 3 〉	통과 (0.57ms, 52.4MB)
     * 테스트 4 〉	통과 (0.85ms, 52.1MB)
     * 테스트 5 〉	통과 (0.64ms, 52.1MB)
     * 테스트 6 〉	통과 (1.04ms, 51.9MB)
     * 테스트 7 〉	통과 (0.68ms, 68.2MB)
     * 테스트 8 〉	통과 (1.22ms, 52MB)
     * 테스트 9 〉	통과 (0.80ms, 52.2MB)
     * 테스트 10 〉	통과 (0.66ms, 52.2MB)
     *
     * 2차 시도
     * 정확성  테스트
     * 테스트 1 〉	통과 (0.02ms, 71.7MB)
     * 테스트 2 〉	통과 (0.03ms, 77.9MB)
     * 테스트 3 〉	통과 (0.03ms, 72MB)
     * 테스트 4 〉	통과 (0.03ms, 74.7MB)
     * 테스트 5 〉	통과 (0.06ms, 72.6MB)
     * 테스트 6 〉	통과 (0.03ms, 74.9MB)
     * 테스트 7 〉	통과 (0.03ms, 81.1MB)
     * 테스트 8 〉	통과 (0.04ms, 78.7MB)
     * 테스트 9 〉	통과 (0.03ms, 74.6MB)
     * 테스트 10 〉	통과 (0.02ms, 74.5MB)
     * 효율성  테스트
     * 테스트 1 〉	통과 (0.87ms, 52.4MB)
     * 테스트 2 〉	통과 (0.35ms, 52.3MB)
     * 테스트 3 〉	통과 (0.50ms, 51.8MB)
     * 테스트 4 〉	통과 (0.64ms, 52.1MB)
     * 테스트 5 〉	통과 (0.52ms, 51.8MB)
     * 테스트 6 〉	통과 (0.73ms, 52.5MB)
     * 테스트 7 〉	통과 (0.42ms, 53MB)
     * 테스트 8 〉	통과 (0.69ms, 54.3MB)
     * 테스트 9 〉	통과 (0.68ms, 51.9MB)
     * 테스트 10 〉	통과 (0.65ms, 52MB)
     *
     *
     */

    public int solution(int m, int n, int[][] puddles) {
        int[][] mapArr = new int[n][m];

        mapArr[0][0] = 1; // 시작점

        for(int[] puddle : puddles) {
            mapArr[puddle[1] - 1][puddle[0] - 1] = -1; // 웅덩이는 -1로 구분
        }

        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(mapArr[i][j] == -1) {
                    mapArr[i][j] = 0; // 웅덩이 발견 시 0으로 초기화
                    continue;
                }

                if(i > 0) mapArr[i][j] += mapArr[i - 1][j]; // 위의 루트수 합산
                if(j > 0) mapArr[i][j] += mapArr[i][j - 1]; // 왼쪽의 루트수 합산
                mapArr[i][j] %= 1000000007;
            }
        }

        return mapArr[n - 1][m - 1];
    }

    /*
    1차 시도
    int y, x = 0;
    int m, n;
    int[][] mapArr;

    public int solution(int m, int n, int[][] puddles) {
        this.m = m;
        this.n = n;
        this.mapArr = new int[n][m];

        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                mapArr[i][j] = 1;
            }
        }

        for(int[] puddle : puddles) {
            mapArr[puddle[1] - 1][puddle[0] - 1] = 0;
        }

        while(!(x == m - 1 && y == n - 1)) {
            moveToTopRight();
            moveToBottomLeft();
        }

        return mapArr[n - 1][m - 1];
    }

    private void moveToTopRight() {
        while (!(x == m - 1 && y == n - 1)) {
            if (x == m - 1 || y == 0) {
                if (x == m - 1) {
                    y++;
                }
                else if (y == 0) {
                    x++;
                }
                calculate();
                return;
            }
            x++;
            y--;
            calculate();
        }
    }

    private void moveToBottomLeft() {
        while (!(x == m - 1 && y == n - 1)) {
            if (y == n - 1 || x == 0) {
                if (y == n - 1) {
                    x++;
                } else if (x == 0) {
                    y++;
                }
                calculate();
                return;
            }
            x--;
            y++;
            calculate();
        }
    }

    private void calculate() {
        if(mapArr[y][x] == 0) return;
        int now = 0;
        if(x - 1 >= 0) now += mapArr[y][x - 1];
        if(y - 1 >= 0) now += mapArr[y - 1][x];
        mapArr[y][x] = now %= 1000000007;
    }


     */

}